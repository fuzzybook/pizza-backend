package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"context"
	"fmt"
	"pizza-backend/common"
	"pizza-backend/models"
	"strings"

	"golang.org/x/exp/slices"
	"gorm.io/gorm"
)

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*models.User, error) {
	context := common.GetContext(ctx)
	preloads := models.GetPreloads(ctx)
	var users []*models.User
	var tx *gorm.DB
	tx = context.Database.Model(&models.User{})
	if slices.Contains(preloads, "details") {
		tx = tx.Preload("Details")
	}
	if slices.Contains(preloads, "bio") {
		tx = tx.Preload("Bio")
	}
	if slices.Contains(preloads, "pro") {
		tx = tx.Preload("Pro")
	}
	if slices.Contains(preloads, "bank") {
		tx = tx.Preload("Bank")
	}

	err := tx.Find(&users).Error
	if err != nil {
		return nil, err
	}
	return users, nil
}

// UsersPaginate is the resolver for the usersPaginate field.
func (r *queryResolver) UsersPaginate(ctx context.Context, input models.UserPages) (*models.UserPagesResponse, error) {
	context := common.GetContext(ctx)
	preloads := models.GetPreloads(ctx)
	var users []*models.User
	var tx *gorm.DB
	tx = context.Database.Model(&models.User{})
	if slices.Contains(preloads, "users.details") {
		tx = tx.Preload("Details")
	}
	if slices.Contains(preloads, "users.bio") {
		tx = tx.Preload("Bio")
	}
	if slices.Contains(preloads, "users.pro") {
		tx = tx.Preload("Pro")
	}
	if slices.Contains(preloads, "users.bank") {
		tx = tx.Preload("Bank")
	}

	if input.SortBy != "" {
		desc := ""
		if input.Descending == true {
			desc = "desc"
		}
		order := fmt.Sprintf("%s %s", strings.ToLower(input.SortBy), desc)
		tx = tx.Order(order)
	}

	if input.Page <= 0 {
		input.Page = 1
	}

	switch {
	case input.PageSize > 100:
		input.PageSize = 100
	case input.PageSize <= 0:
		input.PageSize = 10
	}
	offset := (input.Page - 1) * input.PageSize

	tx = tx.Offset(offset).Limit(input.PageSize)

	err := tx.Find(&users).Error
	if err != nil {
		return nil, err
	}
	var count int64
	err = context.Database.Table("users").Count(&count).Error
	if err != nil {
		return nil, err
	}

	response := models.UserPagesResponse{Page: input.Page, PageSize: input.PageSize, Count: int(count), Users: users}
	return &response, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, userID string) (*models.User, error) {
	context := common.GetContext(ctx)
	var user *models.User
	err := context.Database.Where("id = ?", userID).Find(&user).Error
	if err != nil {
		return nil, err
	}
	return user, nil
}

// Sessions is the resolver for the sessions field.
func (r *queryResolver) Sessions(ctx context.Context) ([]*models.Session, error) {
	context := common.GetContext(ctx)
	var sessions []*models.Session
	err := context.Database.Find(&sessions).Error
	if err != nil {
		return nil, err
	}
	return sessions, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
