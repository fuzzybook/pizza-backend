package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.39

import (
	"context"
	"fmt"
	"pizza-backend/common"
	"pizza-backend/models"
	"strings"

	"golang.org/x/exp/slices"
	"gorm.io/gorm"
)

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*models.User, error) {
	context := common.GetContext(ctx)
	preloads := models.GetPreloads(ctx)
	var users []*models.User
	var tx *gorm.DB
	tx = context.Database.Model(&models.User{})
	if slices.Contains(preloads, "details") {
		tx = tx.Preload("Details")
	}
	if slices.Contains(preloads, "bio") {
		tx = tx.Preload("Bio")
	}
	if slices.Contains(preloads, "pro") {
		tx = tx.Preload("Pro")
	}
	if slices.Contains(preloads, "bank") {
		tx = tx.Preload("Bank")
	}
	if slices.Contains(preloads, "preferences") {
		tx = tx.Preload("Preferences")
	}

	err := tx.Find(&users).Error
	if err != nil {
		return nil, err
	}
	return users, nil
}

// UsersPaginate is the resolver for the usersPaginate field.
func (r *queryResolver) UsersPaginate(ctx context.Context, input models.UserPages) (*models.UserPagesResponse, error) {
	context := common.GetContext(ctx)
	preloads := models.GetPreloads(ctx)
	var users []*models.User
	var tx *gorm.DB
	tx = context.Database.Model(&models.User{})
	if slices.Contains(preloads, "users.details") {
		tx = tx.Preload("Details")
	}
	if slices.Contains(preloads, "users.bio") {
		tx = tx.Preload("Bio")
	}
	if slices.Contains(preloads, "users.pro") {
		tx = tx.Preload("Pro")
	}
	if slices.Contains(preloads, "users.bank") {
		tx = tx.Preload("Bank")
	}
	if slices.Contains(preloads, "users.preferences") {
		tx = tx.Preload("Preferences")
	}

	if input.SortBy != "" {
		desc := ""
		if input.Descending {
			desc = "desc"
		}
		order := fmt.Sprintf("%s %s", strings.ToLower(input.SortBy), desc)
		tx = tx.Order(order)
	}

	if input.Page <= 0 {
		input.Page = 1
	}

	switch {
	case input.PageSize > 100:
		input.PageSize = 100
	case input.PageSize <= 0:
		input.PageSize = 10
	}
	offset := (input.Page - 1) * input.PageSize

	tx = tx.Offset(offset).Limit(input.PageSize)

	err := tx.Find(&users).Error
	if err != nil {
		return nil, err
	}
	var count int64
	err = context.Database.Table("users").Count(&count).Error
	if err != nil {
		return nil, err
	}

	response := models.UserPagesResponse{Page: input.Page, PageSize: input.PageSize, Count: int(count), Users: users}
	return &response, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, userID string) (*models.User, error) {
	context := common.GetContext(ctx)
	var user *models.User
	err := context.Database.Where("id = ?", userID).Find(&user).Error
	if err != nil {
		return nil, err
	}
	return user, nil
}

// Sessions is the resolver for the sessions field.
func (r *queryResolver) Sessions(ctx context.Context) ([]*models.Session, error) {
	context := common.GetContext(ctx)
	var sessions []*models.Session
	err := context.Database.Find(&sessions).Error
	if err != nil {
		return nil, err
	}
	return sessions, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	context := common.GetContext(ctx)
	var user *models.User
	var claimUser *models.ClaimUser
	if claimUser = models.ForContext(ctx); claimUser == nil {
		return nil, fmt.Errorf("access denied")
	}

	err := context.Database.Preload("Details").Preload("Preferences").Where("id = ?", claimUser.Id).Find(&user).Error
	if err != nil {
		return nil, err
	}
	defaultAvatar := "/IMAGES/defaultAvatar.png"
	if user.Avatar == nil {
		user.Avatar = &defaultAvatar
	}
	return user, nil
}

// System is the resolver for the system field.
func (r *queryResolver) System(ctx context.Context) (*models.SystemInfo, error) {
	sys := models.GetSystem()
	return &sys, nil
}

// Logout is the resolver for the logout field.
func (r *queryResolver) Logout(ctx context.Context) (*models.LogoutResult, error) {
	return models.Logout(ctx)
}

// Menu is the resolver for the menu field.
func (r *queryResolver) Menu(ctx context.Context) (*models.Menu, error) {
	return &models.Menu{}, nil
}

// Promos is the resolver for the promos field.
func (r *queryResolver) Promos(ctx context.Context) ([]*models.MenuItem, error) {
	return models.Promos(ctx)
}

// Times is the resolver for the times field.
func (r *queryResolver) WeekTimes(ctx context.Context) (string, error) {
	return models.WeekTimes(ctx)
}

// TodayTimes is the resolver for the todayTimes field.
func (r *queryResolver) TodayTimes(ctx context.Context) (string, error) {
	return models.TodayTimes(ctx)
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
